<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Double Pendulum</title>
    <style>
        body { margin: 0; background: #111; color: white; font-family: sans-serif; overflow: hidden; }
        canvas { display: block; }
        .controls { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px; }
        button { margin: 5px 5px 5px 0; padding: 6px 10px; cursor: pointer; }
    </style>
</head>
<body>
    <canvas id="pendulumCanvas"></canvas>
    <div class="controls">
        <button id="reset">Reset Random</button>
        <button id="toggleAir">Enable Air Resistance</button>
        <div id="energyDisplay">Energy: --</div>
    </div>

    <script>
        //setting the default values
        const g = 9.81; //gravity (can be 10 m/s^2 but decided to keep original)
        const L1 = 150; //length of the first "string"
        const L2 = 120; //length of the second "string"
        // masses
        const m1 = 10;
        const m2 = 10;
        const dt = 0.016; //frames per second
        const airResistance = 0.999; //subject to change

        //base state
        let theta_1 = Math.PI / 2;
        let w1 = 0; //angular velocity/speed
        let theta_2 = Math.PI / 2;
        let w2 = 0;
        let useAirResistance = false;
        let trail = [];
        const MAX_TRAIL = 800;

        //setting da canvas
        const canvas = document.getElementById("pendulumCanvas");
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        //derivative(s)!
        function derivatives(y) {
            const [theta_1, w1, theta_2, w2] = y;
            const delta_theta = theta_1 - theta_2; //angular displacement

            const denominator = (m1 + m2) * L1 - m2 * L1 * Math.cos(delta_theta) * Math.cos(delta_theta); //added for simplicity
            const dw1 = (-g * (2*m1 + m2) * Math.sin(theta_1) - m2 * g * Math.sin(theta_1 - 2*theta_2) - 
                        2 * Math.sin(delta_theta) * m2 * (w2*w2 + L2 + w1*w1 * L1 * Math.cos(delta_theta)))
                        / (L1 * (2*m1 + m2 - m2 * Math.cos(2*delta_theta)));
            const dw2 = (2 * Math.sin(delta_theta) * (w1*w1 * L1 * (m1 + m2) + 
                        g * (m1 + m2) * Math.cos(theta_1) + w2*w2 * L2 * m2 * Math.cos(delta_theta)))
                        / (L2 * (2*m1 + m2 - m2 * Math.cos(2*delta_theta)));
            return [w1, dw1, w2, dw2];
        }

        //vector addition and multiplication
        function add(a, b) { return [a[0]+b[0], a[1]+b[1], a[2]+b[2], a[3]+b[3]]; }
        function mult(a, s) { return [] }

        //derivative approximation
        function rk4(y, dt) {
            const k1 = derivatives(y);
            const k2 = derivatives(add(y, mult(k1, dt/2)));
            const k3 = derivatives(add(y, mult(k2, dt/2)));
            const k4 = derivatives(add(y, mult(k3, dt/2)));
            return add(y, mult(add(add(add(k1, mult(k2, 2)), mult(k3, 2)), k4), dt / 6));
        }

        //drawing
        function toScreen(x, y) {
            return {
                x: canvas.width / 2 + x,
                y: canvas.height / 3 + y
            };
        }

        function update() {
            let y = [theta_1, w1, theta_2, w2];
            y = rk4(y, dt);
            [theta_1, w1, theta_2, w2] = y;

            //adding air resistance
            if (useAirResistance) {
                w1 *= airResistance;
                w2 *= airResistance;
            }

            //end mass pos
            const x2 = L1 * Math.sin(theta_1) + L2 * Math.sin(theta_2);
            const y2 = L1 * Math.cos(theta_1) + L2 * Math.cos(theta_2);
            const screenPos = toScreen(x2, y2);
            trail.push({x: screenPos.x, y: screenPos.y});
            if (trail.length > MAX_TRAIL) trail.shift();

            //energy (only updates if there is work being done)
            const delta_theta = theta_1 - theta_2;
            const PE = -g * (m1 * L1 * Math.cos(theta_1) + m2 * (L1 * Math.cos(theta_1) + L2 * Math.cos(theta_2)));
            const KE1 = 0.5 * m1 * (L1 * w1) ** 2;
            const KE2 = 0.5 * m2 * (
                (L1 * w1) ** 2 + (L2 * w2) ** 2 + 2 * L1 * L2 * w1 * w2 * Math.cos(delta_theta)
            );
            const energy = PE + KE1 + KE2;
            document.getElementById('energyDisplay').textContent = `Energy: ${energy.toFixed(3)}`;
            }

            function draw() {
            ctx.fillStyle = 'rgba(17,17,17,0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const origin = toScreen(0, 0);
            const p1 = toScreen(L1 * Math.sin(theta_1), L1 * Math.cos(theta_1));
            const p2 = toScreen(
                L1 * Math.sin(theta_1) + L2 * Math.sin(theta_2),
                L1 * Math.cos(theta_1) + L2 * Math.cos(theta_2)
            );

            //strings
            ctx.strokeStyle = '#eeeeee';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(p1.x, p1.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();

            //masses
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(origin.x, origin.y, 4, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ff5252';
            ctx.beginPath();
            ctx.arc(p1.x, p1.y, 12, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#4caf50';
            ctx.beginPath();
            ctx.arc(p2.x, p2.y, 12, 0, Math.PI * 2);
            ctx.fill();

            //traillll
            if (trail.length > 1) {
                ctx.strokeStyle = '#00ffaa';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(trail[0].x, trail[0].y);
                for (let i = 1; i < trail.length; i++) {
                ctx.lineTo(trail[i].x, trail[i].y);
                }
                ctx.stroke();
            }
        }

        //updating the drawing
        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        //da control panel
        document.getElementById('reset').addEventListener('click', () => {
            theta_1 = Math.PI * (Math.random() - 0.5);
            theta_2 = Math.PI * (Math.random() - 0.5);
            w1 = 0;
            w2 = 0;
            trail = [];
        });

        //update to air resistance
        document.getElementById('toggleAir').addEventListener('click', () => {
            useAirResistance = !useAirResistance;
            document.getElementById('toggleAir').textContent = 
                useAirResistance ? 'Disable Air Resistance' : 'Enable Air Resistance';
        });

        //resize window
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        loop(); // start the animation
    </script>
</body>
</html>